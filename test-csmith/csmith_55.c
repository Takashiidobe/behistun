/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd73b
 * Options:   --max-funcs 2 --max-expr-complexity 1 --max-block-depth 2
 * Seed:      13175889870174549330
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 23;
   const signed f1 : 16;
   signed f2 : 18;
   signed f3 : 22;
   volatile unsigned f4 : 13;
   const volatile signed f5 : 16;
   const signed f6 : 14;
   volatile signed f7 : 11;
   signed f8 : 3;
   volatile unsigned f9 : 5;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_5 = 0x39D6B9C2L;
static int32_t g_10 = (-3L);
static int32_t * volatile g_9 = &g_10;/* VOLATILE GLOBAL g_9 */
static int32_t g_23 = (-1L);
static int16_t g_24[10][8] = {{0L,0xE308L,0x2A55L,(-4L),0x17F4L,0x7B58L,0x17F4L,(-4L)},{3L,0x32BCL,3L,0xE308L,(-1L),(-1L),1L,0x6E89L},{(-1L),(-1L),(-1L),6L,0x5A52L,(-4L),(-1L),1L},{(-1L),0xDFACL,0xAD25L,0x7B58L,(-1L),0x5B5FL,1L,0x2A55L},{3L,(-1L),0x33DFL,0x17F4L,0x17F4L,0x33DFL,(-1L),3L},{0L,1L,(-4L),1L,0xE308L,1L,0x17F4L,0x5B5FL},{0x90CBL,0xE308L,(-1L),3L,0x7B58L,0x5A52L,0x2A55L,(-4L)},{0x17F4L,0x6E89L,0xAD25L,0x33DFL,1L,9L,(-1L),9L},{(-4L),(-1L),1L,(-1L),(-4L),(-1L),(-1L),(-1L)},{0x2A55L,(-1L),(-1L),0x17F4L,0x32BCL,0L,1L,(-1L)}};
static volatile int8_t g_25 = 0x65L;/* VOLATILE GLOBAL g_25 */
static volatile uint8_t g_30[9][8][3] = {{{0xA8L,1UL,0x78L},{0x23L,255UL,1UL},{246UL,0xAAL,9UL},{250UL,0xE1L,5UL},{0xE0L,0x92L,0x08L},{0x08L,4UL,253UL},{0xB0L,255UL,0x67L},{0x2FL,0UL,253UL}},{{0xE1L,0UL,6UL},{0x5BL,0x0FL,0x0FL},{0xB5L,0UL,0xE2L},{0x6BL,0xC6L,255UL},{246UL,5UL,253UL},{255UL,246UL,9UL},{0x53L,5UL,0UL},{1UL,0xC6L,0UL}},{{0x67L,0UL,0x6BL},{1UL,0x0FL,9UL},{0x4AL,0UL,0UL},{0x53L,0UL,1UL},{5UL,255UL,0xADL},{246UL,4UL,0x53L},{250UL,0x92L,0xFFL},{3UL,0xE1L,0x08L}},{{0x5BL,0xAAL,0UL},{0x92L,255UL,0UL},{0xF7L,1UL,2UL},{0xE1L,0x4DL,3UL},{5UL,0xD7L,0x0FL},{0xE0L,9UL,0x0FL},{5UL,0xC6L,3UL},{246UL,0xD7L,2UL}},{{255UL,0xE7L,0UL},{0xF1L,250UL,0UL},{249UL,0UL,0x08L},{9UL,0UL,0xFFL},{0x67L,246UL,0x53L},{0x4AL,0x4DL,0xADL},{0xF1L,1UL,1UL},{0x23L,1UL,0UL}},{{0x49L,4UL,9UL},{0x6BL,1UL,0x6BL},{3UL,0x92L,0UL},{5UL,0xF6L,0UL},{0xB0L,1UL,9UL},{0UL,1UL,253UL},{0xB0L,0UL,255UL},{5UL,0x0FL,0xE2L}},{{3UL,1UL,0x0FL},{0x6BL,0UL,6UL},{0x49L,0xD7L,253UL},{0x23L,0UL,0x67L},{0xF1L,0xE0L,0x42L},{0UL,0x0FL,0x6BL},{0xDCL,0x23L,0xE0L},{0x23L,1UL,0UL}},{{0xCAL,0xDFL,9UL},{0x08L,246UL,0xC6L},{1UL,0UL,0xB0L},{253UL,255UL,0x5BL},{0xE0L,1UL,0x6DL},{1UL,1UL,0xFFL},{5UL,255UL,0x42L},{0UL,0UL,0x23L}},{{0xE2L,246UL,0x53L},{0x8FL,0xDFL,255UL},{0xFFL,1UL,0UL},{0x4DL,0x23L,0UL},{0xB5L,0x0FL,249UL},{253UL,0xE0L,0x53L},{255UL,246UL,3UL},{0UL,3UL,0xB4L}}};
static struct S0 g_33 = {863,201,-315,-299,83,219,61,-8,-0,3};/* VOLATILE GLOBAL g_33 */
static volatile int32_t g_40 = 0xE6C94210L;/* VOLATILE GLOBAL g_40 */
static volatile int32_t *g_39 = &g_40;
static volatile int32_t **g_38 = &g_39;
static volatile int32_t *** volatile g_37 = &g_38;/* VOLATILE GLOBAL g_37 */
static volatile int32_t *** volatile * volatile g_42 = &g_37;/* VOLATILE GLOBAL g_42 */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_1(void);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_9 g_10 g_30 g_33 g_24 g_37 g_42
 * writes: g_5 g_10 g_30 g_37
 */
static struct S0  func_1(void)
{ /* block id: 0 */
    int32_t **l_2 = (void*)0;
    int32_t *l_4 = &g_5;
    int32_t **l_3 = &l_4;
    int32_t l_20 = 0L;
    int32_t l_22 = 0x9061E942L;
    uint32_t l_26 = 0xA718BA30L;
    int16_t l_34 = 1L;
    volatile int32_t *** volatile *l_41 = (void*)0;
    (*l_3) = (void*)0;
    if (g_5)
    { /* block id: 2 */
        int8_t l_11 = 4L;
        uint32_t l_17 = 0x8E4C12F6L;
        int32_t l_21 = 0xDDDD5D57L;
        int32_t l_29 = (-1L);
        for (g_5 = 0; (g_5 >= (-30)); g_5 = safe_sub_func_int8_t_s_s(g_5, 7))
        { /* block id: 5 */
            uint64_t l_8[10] = {18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL};
            int i;
            if (g_5)
                break;
            (*g_9) = l_8[3];
        }
        if (l_11)
        { /* block id: 9 */
            uint16_t l_12[4] = {0UL,0UL,0UL,0UL};
            int i;
            l_12[2] = (*g_9);
        }
        else
        { /* block id: 11 */
            int32_t *l_13 = (void*)0;
            int32_t *l_14 = &g_5;
            int32_t *l_15 = &g_10;
            int32_t *l_16[7][7] = {{(void*)0,&g_10,(void*)0,&g_5,&g_10,&g_5,(void*)0},{&g_10,&g_10,&g_5,(void*)0,&g_5,&g_5,(void*)0},{(void*)0,&g_10,&g_5,&g_5,&g_5,&g_5,&g_10},{&g_5,&g_10,&g_10,(void*)0,&g_5,(void*)0,(void*)0},{&g_5,(void*)0,&g_10,&g_10,&g_10,(void*)0,&g_5},{(void*)0,(void*)0,&g_5,(void*)0,&g_10,&g_10,&g_5},{&g_10,&g_5,&g_5,&g_5,&g_5,&g_10,(void*)0}};
            int i, j;
            l_17++;
            (*l_14) = (*g_9);
            l_26--;
            --g_30[2][4][2];
        }
    }
    else
    { /* block id: 17 */
        return g_33;
    }
    for (g_5 = 0; (g_5 <= 2); g_5 += 1)
    { /* block id: 22 */
        uint32_t l_35[7][1][10] = {{{4294967287UL,4294967289UL,4294967295UL,0x7BEB33E2L,4294967289UL,4294967295UL,4294967295UL,4294967289UL,0x7BEB33E2L,4294967295UL}},{{4294967295UL,4294967295UL,4294967289UL,0x7BEB33E2L,4294967295UL,4294967289UL,4294967287UL,0xC94644A7L,4294967287UL,4294967289UL}},{{0x9764F797L,4294967289UL,0x70AD0C79L,4294967289UL,0x9764F797L,0xCA180BB4L,4294967287UL,4294967295UL,4294967291UL,4294967291UL}},{{0x7BEB33E2L,4294967295UL,0x1E07D3A0L,4294967289UL,4294967289UL,0x1E07D3A0L,4294967295UL,0x7BEB33E2L,0x70AD0C79L,4294967291UL}},{{0xC94644A7L,4294967289UL,4294967295UL,0UL,0x9764F797L,4294967287UL,0x9764F797L,0UL,4294967295UL,4294967289UL}},{{0x1E07D3A0L,0xCA180BB4L,4294967295UL,0x9764F797L,4294967295UL,0UL,0x7BEB33E2L,0x7BEB33E2L,0UL,4294967295UL}},{{4294967291UL,0x1E07D3A0L,0x1E07D3A0L,4294967291UL,4294967289UL,0UL,0xC94644A7L,4294967295UL,0x70AD0C79L,4294967289UL}}};
        int i, j, k;
        for (l_20 = 2; (l_20 >= 0); l_20 -= 1)
        { /* block id: 25 */
            int i, j;
            (*g_9) = g_24[(g_5 + 4)][(g_5 + 4)];
        }
        (*g_9) = l_34;
        if (l_35[2][0][9])
            break;
        for (g_10 = 2; (g_10 >= 0); g_10 -= 1)
        { /* block id: 32 */
            int32_t *l_36 = &l_20;
            int i, j;
            (*l_36) = g_24[(g_5 + 7)][(g_10 + 1)];
            if (g_24[(g_5 + 4)][g_10])
                continue;
        }
    }
    (*g_42) = g_37;
    return g_33;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_10, "g_10", print_hash_value);
    transparent_crc(g_23, "g_23", print_hash_value);
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 8; j++)
        {
            transparent_crc(g_24[i][j], "g_24[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_25, "g_25", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        for (j = 0; j < 8; j++)
        {
            for (k = 0; k < 3; k++)
            {
                transparent_crc(g_30[i][j][k], "g_30[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_33.f0, "g_33.f0", print_hash_value);
    transparent_crc(g_33.f1, "g_33.f1", print_hash_value);
    transparent_crc(g_33.f2, "g_33.f2", print_hash_value);
    transparent_crc(g_33.f3, "g_33.f3", print_hash_value);
    transparent_crc(g_33.f4, "g_33.f4", print_hash_value);
    transparent_crc(g_33.f5, "g_33.f5", print_hash_value);
    transparent_crc(g_33.f6, "g_33.f6", print_hash_value);
    transparent_crc(g_33.f7, "g_33.f7", print_hash_value);
    transparent_crc(g_33.f8, "g_33.f8", print_hash_value);
    transparent_crc(g_33.f9, "g_33.f9", print_hash_value);
    transparent_crc(g_40, "g_40", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 16
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 4
XXX structs with bitfields in the program: 1
breakdown:
   indirect level: 0, occurrence: 1
XXX full-bitfields structs in the program: 1
breakdown:
   indirect level: 0, occurrence: 1
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 2
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 2
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 4

XXX total number of pointers: 14

XXX times a variable address is taken: 19
XXX times a pointer is dereferenced on RHS: 2
breakdown:
   depth: 1, occurrence: 2
XXX times a pointer is dereferenced on LHS: 7
breakdown:
   depth: 1, occurrence: 7
XXX times a pointer is compared with null: 0
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 158

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 10
   level: 2, occurrence: 5
XXX number of pointers point to pointers: 6
XXX number of pointers point to scalars: 8
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 35.7
XXX average alias set size: 1.14

XXX times a non-volatile is read: 18
XXX times a non-volatile is write: 16
XXX times a volatile is read: 3
XXX    times read thru a pointer: 0
XXX times a volatile is write: 6
XXX    times written thru a pointer: 1
XXX times a volatile is available for access: 31
XXX percentage of non-volatile access: 79.1

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 22
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 5
   depth: 1, occurrence: 7
   depth: 2, occurrence: 10

XXX percentage a fresh-made variable is used: 42.5
XXX percentage an existing variable is used: 57.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

