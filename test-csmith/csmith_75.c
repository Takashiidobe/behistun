/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd73b
 * Options:   --max-funcs 2 --max-expr-complexity 1 --max-block-depth 2
 * Seed:      561130405691598778
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const volatile int8_t  f0;
   uint32_t  f1;
};

union U1 {
   const int8_t  f0;
   uint16_t  f1;
   volatile unsigned f2 : 30;
   volatile uint32_t  f3;
   int32_t  f4;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0x8F69F7FDL;
static int32_t g_8 = 0x2579253AL;
static int32_t *g_7 = &g_8;
static int32_t g_12 = 0x35290CE9L;
static uint32_t g_13[5] = {8UL,8UL,8UL,8UL,8UL};
static int32_t * volatile g_19 = &g_12;/* VOLATILE GLOBAL g_19 */
static union U1 g_23 = {0xCAL};/* VOLATILE GLOBAL g_23 */
static union U1 g_25 = {0xB4L};/* VOLATILE GLOBAL g_25 */
static int32_t ** volatile g_27 = (void*)0;/* VOLATILE GLOBAL g_27 */
static uint32_t g_31[7] = {0xB88A615BL,0xB88A615BL,0xB88A615BL,0xB88A615BL,0xB88A615BL,0xB88A615BL,0xB88A615BL};
static uint16_t g_42 = 0xA1D2L;
static union U1 *g_49[5] = {&g_23,&g_23,&g_23,&g_23,&g_23};
static union U1 ** volatile g_48 = &g_49[1];/* VOLATILE GLOBAL g_48 */
static union U0 ** volatile g_51 = (void*)0;/* VOLATILE GLOBAL g_51 */
static union U0 g_55 = {0L};/* VOLATILE GLOBAL g_55 */
static union U0 *g_54 = &g_55;
static union U0 ** volatile g_53 = &g_54;/* VOLATILE GLOBAL g_53 */
static volatile uint16_t g_59 = 0x8B4DL;/* VOLATILE GLOBAL g_59 */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_1(void);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_19 g_12 g_7 g_8 g_31 g_42 g_48 g_53 g_59 g_55.f1 g_25.f0 g_13
 * writes: g_2 g_8 g_12 g_31 g_42 g_49 g_54 g_53 g_59 g_55.f1
 */
static uint64_t  func_1(void)
{ /* block id: 0 */
    int32_t l_5 = 0xDD952EAAL;
    union U1 *l_24[9][9][1] = {{{&g_23},{&g_23},{&g_25},{&g_25},{&g_25},{(void*)0},{&g_25},{&g_23},{&g_23}},{{&g_23},{&g_25},{&g_23},{&g_23},{&g_23},{&g_25},{(void*)0},{&g_25},{&g_25}},{{&g_25},{&g_23},{&g_23},{&g_25},{&g_23},{&g_23},{&g_25},{&g_23},{(void*)0}},{{(void*)0},{&g_23},{&g_23},{&g_25},{&g_23},{&g_23},{&g_23},{&g_23},{&g_23}},{{&g_23},{&g_23},{&g_23},{&g_23},{&g_25},{&g_25},{&g_23},{&g_25},{&g_23}},{{&g_25},{&g_25},{&g_23},{&g_23},{&g_23},{&g_23},{&g_23},{&g_23},{&g_23}},{{&g_23},{&g_23},{&g_25},{&g_23},{&g_25},{&g_23},{&g_23},{&g_25},{&g_23}},{{&g_25},{&g_23},{&g_23},{&g_23},{&g_23},{&g_23},{&g_23},{&g_23},{&g_23}},{{&g_23},{&g_25},{&g_25},{&g_23},{&g_25},{&g_23},{&g_25},{&g_25},{&g_23}}};
    int32_t l_38 = (-1L);
    int32_t l_39 = 0x823142ACL;
    int32_t l_40[5][1] = {{0x73D5EAA9L},{(-5L)},{0x73D5EAA9L},{(-5L)},{0x73D5EAA9L}};
    uint8_t l_45 = 255UL;
    int32_t *l_58 = &l_40[0][0];
    int i, j, k;
    for (g_2 = (-24); (g_2 != (-22)); g_2++)
    { /* block id: 3 */
        int32_t *l_6[4][4] = {{&g_2,&g_2,&g_2,&g_2},{&g_2,&g_2,&g_2,&g_2},{&g_2,&g_2,&g_2,&g_2},{&g_2,&g_2,&g_2,&g_2}};
        int i, j;
    }
lbl_63:
    for (g_8 = 0; (g_8 > (-2)); --g_8)
    { /* block id: 17 */
        uint32_t l_18 = 4294967295UL;
        int32_t l_20 = 0x39D3CD36L;
        union U1 *l_22 = &g_23;
        (*g_19) = l_18;
        l_20 |= (*g_19);
    }
    for (g_8 = 0; (g_8 <= 0); g_8 += 1)
    { /* block id: 30 */
        uint32_t l_34 = 0x446ED9A8L;
        int32_t l_36 = 0xB5CFE74DL;
        int32_t l_37 = 0xA1B6BD7AL;
        int32_t l_41[1][5];
        union U0 *l_50 = (void*)0;
        int32_t *l_62[5];
        int i, j;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 5; j++)
                l_41[i][j] = 3L;
        }
        for (i = 0; i < 5; i++)
            l_62[i] = &l_40[0][0];
        if ((*g_7))
        { /* block id: 31 */
            int32_t *l_29 = &g_12;
            (*l_29) &= l_5;
        }
        else
        { /* block id: 33 */
            int32_t *l_30[7][10] = {{(void*)0,&g_12,&g_8,&g_2,(void*)0,&g_2,&g_8,&g_12,(void*)0,&g_12},{&g_12,&g_2,&l_5,&l_5,&l_5,&g_2,&g_12,&l_5,&g_12,&g_2},{(void*)0,&l_5,&g_12,&l_5,(void*)0,&l_5,&g_12,&l_5,(void*)0,&l_5},{&l_5,&l_5,&l_5,&g_2,&g_12,&l_5,&g_12,&g_2,&l_5,&l_5},{(void*)0,&g_2,&g_8,&g_12,(void*)0,&g_12,&g_8,&g_2,(void*)0,&g_2},{&g_12,&g_12,&l_5,&l_5,&l_5,&g_12,&g_12,&l_5,&g_12,&g_12},{(void*)0,&l_5,&g_12,&l_5,(void*)0,&l_5,&g_12,&l_5,(void*)0,&l_5}};
            int i, j;
            g_31[4]--;
            (*g_19) = (*g_19);
        }
        if (l_34)
        { /* block id: 37 */
            int32_t *l_35[10] = {&g_12,&g_12,&g_12,&g_12,&g_12,&g_12,&g_12,&g_12,&g_12,&g_12};
            int i;
            if ((*g_7))
                break;
            --g_42;
            --l_45;
            l_41[0][2] = 0xFD423136L;
        }
        else
        { /* block id: 42 */
            union U0 **l_52 = (void*)0;
            (*g_48) = &g_25;
            if (l_45)
                continue;
            (*g_53) = l_50;
        }
        for (l_34 = 1; (l_34 <= 6); l_34 += 1)
        { /* block id: 49 */
            int32_t *l_56 = (void*)0;
            int32_t **l_57[8][5] = {{&g_7,&g_7,&l_56,&g_7,&g_7},{&g_7,&l_56,&g_7,&g_7,&l_56},{&g_7,(void*)0,&g_7,&g_7,&g_7},{&l_56,&l_56,&g_7,&l_56,&l_56},{&g_7,&g_7,&g_7,(void*)0,&g_7},{&l_56,&g_7,&g_7,&l_56,&g_7},{&g_7,&g_7,&l_56,&g_7,&g_7},{&g_7,&l_56,&g_7,&g_7,&g_7}};
            int i, j;
            l_58 = l_56;
            g_53 = &g_54;
            g_59--;
        }
        l_40[0][0] ^= 8L;
        for (g_55.f1 = 0; (g_55.f1 <= 0); g_55.f1 += 1)
        { /* block id: 57 */
            (*g_19) &= 0xD6F6C97CL;
            l_40[0][0] = 0x3742197FL;
        }
    }
    for (l_5 = 0; (l_5 <= 0); l_5 += 1)
    { /* block id: 64 */
        int16_t l_64[6] = {0xA7ADL,0xA7ADL,0xA7ADL,0xA7ADL,0xA7ADL,0xA7ADL};
        int i;
        for (l_39 = 0; (l_39 <= 0); l_39 += 1)
        { /* block id: 67 */
            return g_25.f0;
        }
        for (g_2 = 0; (g_2 <= 6); g_2 += 1)
        { /* block id: 72 */
            int i;
            if (l_39)
                goto lbl_63;
            if (g_31[(l_5 + 5)])
                continue;
            return g_13[0];
        }
        return l_64[1];
    }
    return g_2;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_12, "g_12", print_hash_value);
    for (i = 0; i < 5; i++)
    {
        transparent_crc(g_13[i], "g_13[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_23.f0, "g_23.f0", print_hash_value);
    transparent_crc(g_25.f0, "g_25.f0", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        transparent_crc(g_31[i], "g_31[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_42, "g_42", print_hash_value);
    transparent_crc(g_55.f0, "g_55.f0", print_hash_value);
    transparent_crc(g_59, "g_59", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 26
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 2
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 32
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 1
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 2
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 8

XXX total number of pointers: 24

XXX times a variable address is taken: 88
XXX times a pointer is dereferenced on RHS: 9
breakdown:
   depth: 1, occurrence: 9
XXX times a pointer is dereferenced on LHS: 11
breakdown:
   depth: 1, occurrence: 11
XXX times a pointer is compared with null: 0
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 279

XXX max dereference level: 1
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 52
XXX number of pointers point to pointers: 8
XXX number of pointers point to scalars: 11
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 45.8
XXX average alias set size: 1.62

XXX times a non-volatile is read: 39
XXX times a non-volatile is write: 38
XXX times a volatile is read: 3
XXX    times read thru a pointer: 0
XXX times a volatile is write: 7
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 290
XXX percentage of non-volatile access: 88.5

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 34
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 5
   depth: 1, occurrence: 10
   depth: 2, occurrence: 19

XXX percentage a fresh-made variable is used: 30.6
XXX percentage an existing variable is used: 69.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

